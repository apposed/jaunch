#include <CoreFoundation/CoreFoundation.h>
#include <objc/objc.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <sys/xattr.h>
#include <dlfcn.h>
#include <pthread.h>
#include <spawn.h>
#include <stdlib.h>

// Declare needed AppKit function without including AppKit,
// to avoid difficulties with Objective-C versus pure C.
extern void NSApplicationLoad(void);

#include "common.h"

#define OS_NAME "macos"

extern char **environ;

struct LaunchConfiguration {
    LaunchFunc launch_runtime;
    size_t argc;
    const char **argv;
    int exit_code;
};

static struct LaunchConfiguration config = {
    .launch_runtime = NULL,
    .argc = 0,
    .argv = NULL,
    .exit_code = 0
};

static void dummy_call_back(void *info) { }

static void *launch_call_back(void *dummy) {
    config.exit_code = config.launch_runtime(config.argc, config.argv);
    CFRunLoopStop(CFRunLoopGetMain());
    return NULL;
}

/*
 * Launch runtime on a new thread.
 */
int launch_on_pthread(const LaunchFunc launch_runtime,
    const size_t argc, const char **argv)
{
    // Save arguments into global struct, for later retrieval.
    config.launch_runtime = launch_runtime;
    config.argc = argc;
    config.argv = argv;

    // Call the launch function on a dedicated thread.
    pthread_t thread;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&thread, &attr, launch_call_back, NULL);
    pthread_attr_destroy(&attr);

    // Run the AppKit event loop here on the main thread.
    CFRunLoopSourceContext context;
    memset(&context, 0, sizeof(context));
    context.perform = &dummy_call_back;

    CFRunLoopSourceRef ref = CFRunLoopSourceCreate(NULL, 0, &context);
    CFRunLoopAddSource (CFRunLoopGetCurrent(), ref, kCFRunLoopCommonModes);
    CFRunLoopRun();

    pthread_join(thread, NULL);

    return config.exit_code;
}

int handle_translocation(const int argc, const char *argv[]) {
    // Note: This function was generated by Claude.ai. It works
    // for now, but it uses internal security framework functions.

    // Load Security framework
    void *security_framework = dlopen("/System/Library/Frameworks/Security.framework/Security", RTLD_LAZY);
    if (!security_framework) {
        debug("[JAUNCH-MACOS] Failed to load Security framework");
        return 0; // Continue with normal execution
    }

    // Get function pointers
    Boolean (*isTranslocatedFunc)(CFURLRef, Boolean *, CFErrorRef *) =
        dlsym(security_framework, "SecTranslocateIsTranslocatedURL");
    CFURLRef (*getOriginalPathFunc)(CFURLRef, CFErrorRef *) =
        dlsym(security_framework, "SecTranslocateCreateOriginalPathForURL");

    if (!isTranslocatedFunc || !getOriginalPathFunc) {
        debug("[JAUNCH-MACOS] Failed to find translocation functions");
        dlclose(security_framework);
        return 0; // Continue with normal execution
    }

    // Get bundle path
    CFBundleRef mainBundle = CFBundleGetMainBundle();
    if (!mainBundle) {
        debug("[JAUNCH-MACOS] Failed to get main bundle");
        dlclose(security_framework);
        return 0;
    }

    CFURLRef bundleURL = CFBundleCopyBundleURL(mainBundle);
    if (!bundleURL) {
        debug("[JAUNCH-MACOS] Failed to get bundle URL");
        dlclose(security_framework);
        return 0;
    }

    // Check if app is translocated
    Boolean isTranslocated = FALSE;
    isTranslocatedFunc(bundleURL, &isTranslocated, NULL);

    if (!isTranslocated) {
        debug("[JAUNCH-MACOS] Application is not translocated");
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0; // Continue with normal execution
    }

    debug("[JAUNCH-MACOS] Application is translocated, finding original path");

    // Get the original path
    CFURLRef originalURL = getOriginalPathFunc(bundleURL, NULL);
    if (!originalURL) {
        debug("[JAUNCH-MACOS] Failed to get original path");
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    // Convert the URL to a filesystem path
    char originalPath[PATH_MAX];
    if (!CFURLGetFileSystemRepresentation(originalURL, TRUE, (UInt8*)originalPath, PATH_MAX)) {
        debug("[JAUNCH-MACOS] Failed to convert URL to path");
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    debug("[JAUNCH-MACOS] Original path: %s", originalPath);

    // Get path to the executable within the bundle
    CFURLRef executableURL = CFBundleCopyExecutableURL(mainBundle);
    if (!executableURL) {
        debug("[JAUNCH-MACOS] Failed to get executable URL");
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    char executablePath[PATH_MAX];
    if (!CFURLGetFileSystemRepresentation(executableURL, TRUE, (UInt8*)executablePath, PATH_MAX)) {
        debug("[JAUNCH-MACOS] Failed to convert executable URL to path");
        CFRelease(executableURL);
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    // Get relative path of executable within bundle
    char bundlePath[PATH_MAX];
    if (!CFURLGetFileSystemRepresentation(bundleURL, TRUE, (UInt8*)bundlePath, PATH_MAX)) {
        debug("[JAUNCH-MACOS] Failed to convert bundle URL to path");
        CFRelease(executableURL);
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    char *relativeExecPath = executablePath + strlen(bundlePath);

    // Construct path to original executable
    char originalExecPath[PATH_MAX];
    snprintf(originalExecPath, PATH_MAX, "%s%s", originalPath, relativeExecPath);

    debug("[JAUNCH-MACOS] Original executable path: %s", originalExecPath);

    // Remove quarantine attribute from the original bundle
    char xattrCmd[PATH_MAX * 2];
    snprintf(xattrCmd, PATH_MAX * 2, "xattr -dr com.apple.quarantine \"%s\"", originalPath);
    debug("[JAUNCH-MACOS] Removing quarantine attribute: %s", xattrCmd);
    system(xattrCmd);

    // Prepare to relaunch from original location
    char **args = (char **)malloc((argc + 1) * sizeof(char *));
    args[0] = originalExecPath;

    // Copy all arguments
    for (int i = 1; i < argc; i++) {
        args[i] = (char *)argv[i];
    }
    args[argc] = NULL;

    // Clean up CF objects
    CFRelease(executableURL);
    CFRelease(originalURL);
    CFRelease(bundleURL);
    dlclose(security_framework);

    // Execute the original application
    debug("[JAUNCH-MACOS] Relaunching from original location");
    pid_t pid;
    int status = posix_spawn(&pid, originalExecPath, NULL, NULL, args, environ);

    if (status == 0) {
        debug("[JAUNCH-MACOS] Successfully relaunched, exiting translocated instance");
        free(args);
        exit(0); // Exit this translocated instance
    }
    else {
        debug("[JAUNCH-MACOS] Failed to relaunch: %s", strerror(status));
        free(args);
        return 0; // Continue with normal execution as fallback
    }
}

// ===========================================================
//              common.h FUNCTION IMPLEMENTATIONS
// ===========================================================

void setup(const int argc, const char *argv[]) {
    // Thanks to https://objective-see.org/blog/blog_0x15.html.
    // See doc/MACOS.md for why we have to do this.
  handle_translocation(argc, argv);
}
void teardown() {}

void init_threads() {}

/*
 * The macOS way of displaying a graphical error message.
 *
 * It uses Objective C calls to initialize the application,
 * then create, configure, and display the alert.
 *
 * The reason the code is ugly and hard to read is because we
 * are calling into Objective C from pure C, which goes against
 * the grain of Apple's recommended technology choices.
 * (If you are an expert macOS C developer reading this, please
 * feel warmly invited to file an issue or PR improving this!)
 */
void show_alert(const char *title, const char *message) {
    // Note: This function was generated by Claude.ai. It works, but
    // we make no guarantees about its awesomeness or lack thereof. :-)

    // Get necessary classes
    Class NSAutoreleasePool = objc_getClass("NSAutoreleasePool");
    Class NSApplication = objc_getClass("NSApplication");
    Class NSString = objc_getClass("NSString");
    Class NSAlert = objc_getClass("NSAlert");

    // Create autorelease pool
    id pool = ((id (*)(id, SEL))objc_msgSend)((id)NSAutoreleasePool, sel_registerName("alloc"));
    pool = ((id (*)(id, SEL))objc_msgSend)(pool, sel_registerName("init"));

    // Initialize application
    ((void(*)(void))NSApplicationLoad)();  // Cast the function pointer
    id app = ((id (*)(id, SEL))objc_msgSend)((id)NSApplication, sel_registerName("sharedApplication"));

    // Create strings
    id nsTitle = ((id (*)(id, SEL, const char*))objc_msgSend)((id)NSString,
        sel_registerName("stringWithUTF8String:"), title);
    id nsMessage = ((id (*)(id, SEL, const char*))objc_msgSend)((id)NSString,
        sel_registerName("stringWithUTF8String:"), message);

    // Create and configure alert
    id alert = ((id (*)(id, SEL))objc_msgSend)((id)NSAlert, sel_registerName("alloc"));
    alert = ((id (*)(id, SEL))objc_msgSend)(alert, sel_registerName("init"));
    ((void (*)(id, SEL, id))objc_msgSend)(alert, sel_registerName("setMessageText:"), nsTitle);
    ((void (*)(id, SEL, id))objc_msgSend)(alert, sel_registerName("setInformativeText:"), nsMessage);

    // Show alert
    ((void (*)(id, SEL))objc_msgSend)(alert, sel_registerName("runModal"));

    // Release pool
    ((void (*)(id, SEL))objc_msgSend)(pool, sel_registerName("drain"));
}

/*
 * The macOS way of launching a runtime.
 *
 * It starts a new thread using pthread_create, which calls the launch function.
 * Meanwhile, on this thread (main), the CoreFoundation event loop is run.
 * All so that Java's AWT subsystem can work without freezing up the process.
 */
int launch(const LaunchFunc launch_runtime, const size_t argc, const char **argv) {
    return launch_on_pthread(launch_runtime, argc, argv);
}
