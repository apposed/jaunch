#include <CoreFoundation/CoreFoundation.h>
#include <objc/objc.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <sys/xattr.h>
#include <dlfcn.h>
#include <spawn.h>
#include <stdlib.h>
#include <signal.h>

// Declare needed AppKit function without including AppKit,
// to avoid difficulties with Objective-C versus pure C.
extern void NSApplicationLoad(void);

#include "common.h"
#include "thread.h"

#define OS_NAME "macos"

/*
 * ===========================================================================
 * MACOS LAUNCHER IMPLEMENTATION NOTES
 * ===========================================================================
 *
 * This file implements macOS-specific runtime launching with careful handling
 * of CoreFoundation runloop management for both GUI and non-GUI applications.
 *
 * RUNLOOP MODES SUPPORTED:
 * - "main": Runtime runs on main thread (for -XstartOnFirstThread behavior)
 * - "park": Runtime runs on pthread, main thread runs the event loop
 * - "none": Runtime runs on main thread, no event loop management
 * ===========================================================================
 */

extern char **environ;

static void dummy_call_back(void *info) { }

int handle_translocation(const int argc, const char *argv[]) {
    // Note: This function was generated by Claude.ai. It works
    // for now, but it uses internal security framework functions.

    // Load Security framework
    void *security_framework = dlopen("/System/Library/Frameworks/Security.framework/Security", RTLD_LAZY);
    if (!security_framework) {
        debug("[JAUNCH-MACOS] Failed to load Security framework");
        return 0; // Continue with normal execution
    }

    // Get function pointers
    Boolean (*isTranslocatedFunc)(CFURLRef, Boolean *, CFErrorRef *) =
        dlsym(security_framework, "SecTranslocateIsTranslocatedURL");
    CFURLRef (*getOriginalPathFunc)(CFURLRef, CFErrorRef *) =
        dlsym(security_framework, "SecTranslocateCreateOriginalPathForURL");

    if (!isTranslocatedFunc || !getOriginalPathFunc) {
        debug("[JAUNCH-MACOS] Failed to find translocation functions");
        dlclose(security_framework);
        return 0; // Continue with normal execution
    }

    // Get bundle path
    CFBundleRef mainBundle = CFBundleGetMainBundle();
    if (!mainBundle) {
        debug("[JAUNCH-MACOS] Failed to get main bundle");
        dlclose(security_framework);
        return 0;
    }

    CFURLRef bundleURL = CFBundleCopyBundleURL(mainBundle);
    if (!bundleURL) {
        debug("[JAUNCH-MACOS] Failed to get bundle URL");
        dlclose(security_framework);
        return 0;
    }

    // Check if app is translocated
    Boolean isTranslocated = FALSE;
    isTranslocatedFunc(bundleURL, &isTranslocated, NULL);

    if (!isTranslocated) {
        debug("[JAUNCH-MACOS] Application is not translocated");
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0; // Continue with normal execution
    }

    debug("[JAUNCH-MACOS] Application is translocated, finding original path");

    // Get the original path
    CFURLRef originalURL = getOriginalPathFunc(bundleURL, NULL);
    if (!originalURL) {
        debug("[JAUNCH-MACOS] Failed to get original path");
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    // Convert the URL to a filesystem path
    char originalPath[PATH_MAX];
    if (!CFURLGetFileSystemRepresentation(originalURL, TRUE, (UInt8*)originalPath, PATH_MAX)) {
        debug("[JAUNCH-MACOS] Failed to convert URL to path");
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    debug("[JAUNCH-MACOS] Original path: %s", originalPath);

    // Get path to the executable within the bundle
    CFURLRef executableURL = CFBundleCopyExecutableURL(mainBundle);
    if (!executableURL) {
        debug("[JAUNCH-MACOS] Failed to get executable URL");
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    char executablePath[PATH_MAX];
    if (!CFURLGetFileSystemRepresentation(executableURL, TRUE, (UInt8*)executablePath, PATH_MAX)) {
        debug("[JAUNCH-MACOS] Failed to convert executable URL to path");
        CFRelease(executableURL);
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    // Get relative path of executable within bundle
    char bundlePath[PATH_MAX];
    if (!CFURLGetFileSystemRepresentation(bundleURL, TRUE, (UInt8*)bundlePath, PATH_MAX)) {
        debug("[JAUNCH-MACOS] Failed to convert bundle URL to path");
        CFRelease(executableURL);
        CFRelease(originalURL);
        CFRelease(bundleURL);
        dlclose(security_framework);
        return 0;
    }

    char *relativeExecPath = executablePath + strlen(bundlePath);

    // Construct path to original executable
    char originalExecPath[PATH_MAX];
    snprintf(originalExecPath, PATH_MAX, "%s%s", originalPath, relativeExecPath);

    debug("[JAUNCH-MACOS] Original executable path: %s", originalExecPath);

    // Remove quarantine attribute from the original bundle
    char xattrCmd[PATH_MAX * 2];
    snprintf(xattrCmd, PATH_MAX * 2, "xattr -dr com.apple.quarantine \"%s\"", originalPath);
    debug("[JAUNCH-MACOS] Removing quarantine attribute: %s", xattrCmd);
    system(xattrCmd);

    // Prepare to relaunch from original location
    char **args = (char **)malloc((argc + 1) * sizeof(char *));
    args[0] = originalExecPath;

    // Copy all arguments
    for (int i = 1; i < argc; i++) {
        args[i] = (char *)argv[i];
    }
    args[argc] = NULL;

    // Clean up CF objects
    CFRelease(executableURL);
    CFRelease(originalURL);
    CFRelease(bundleURL);
    dlclose(security_framework);

    // Execute the original application
    debug("[JAUNCH-MACOS] Relaunching from original location");
    pid_t pid;
    int status = posix_spawn(&pid, originalExecPath, NULL, NULL, args, environ);

    if (status == 0) {
        debug("[JAUNCH-MACOS] Successfully relaunched, exiting translocated instance");
        free(args);
        exit(0); // Exit this translocated instance
    }
    else {
        debug("[JAUNCH-MACOS] Failed to relaunch: %s", strerror(status));
        free(args);
        return 0; // Continue with normal execution as fallback
    }
}

// ===========================================================
//              common.h FUNCTION IMPLEMENTATIONS
// ===========================================================

void setup(const int argc, const char *argv[]) {
    // Thanks to https://objective-see.org/blog/blog_0x15.html.
    // See doc/MACOS.md for why we have to do this.
    handle_translocation(argc, argv);
}
void teardown() {}

void runloop_config(const char *directive) {
    extern ThreadContext *ctx;
    if (directive && strcmp(directive, "JVM") == 0) {
        // JVM default: park main thread in event loop.
        ctx->runloop_mode = "park";
        debug("[JAUNCH-MACOS] runloop_mode -> %s [auto]", ctx->runloop_mode);
    }
}
void runloop_run(const char *mode) {
    extern ThreadContext *ctx;
    ctx->runloop_mode = (char *)mode;
    debug("[JAUNCH-MACOS] runloop_mode -> %s", ctx->runloop_mode);

    int park_mode = strcmp(mode, "park") == 0;
    if (park_mode) {
        debug("[JAUNCH-MACOS] Park mode -- initializing macOS CoreFoundation runloop");

        // Signal early completion, transitioning to runloop state. This
        // releases the directive thread while we block the main thread with
        // this runloop.
        debug("[JAUNCH-MACOS] Invoking ctx_signal_early_completion");
        ctx_lock();
        ctx_signal_early_completion(STATE_RUNLOOP);
        ctx_unlock();
        debug("[JAUNCH-MACOS] ctx_signal_early_completion invoked");

        // Create a far-future timer to keep the runloop active.
        // This timer is necessary to prevent the runloop from exiting immediately
        // when there are no other sources/timers scheduled.
        debug("[JAUNCH-MACOS] Creating far-future timer");
        CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
            1.0e20, 0.0, 0, 0, (CFRunLoopTimerCallBack)dummy_call_back, NULL);
        CFRunLoopAddTimer(CFRunLoopGetMain(), timer, kCFRunLoopDefaultMode);
        CFRelease(timer);
        debug("[JAUNCH-MACOS] Timer created");

        // Run the main runloop.
        debug("[JAUNCH-MACOS] Invoking CFRunLoopRun");
        CFRunLoopRun();
        debug("[JAUNCH-MACOS] CFRunLoopRun completed");

        // Now that the runloop has exited, transition back to WAITING state.
        ctx_lock();
        if (ctx->state == STATE_RUNLOOP) {
            debug("[JAUNCH-MACOS] Transitioning from RUNLOOP to WAITING after CFRunLoopRun returned");
            ctx_set_state(STATE_WAITING);
            ctx_signal_main();
        }
        ctx_unlock();
    } else {
        debug("[JAUNCH-MACOS] Runloop mode '%s' - no event loop needed", mode);
        // For non-park modes, just return normally - no early completion needed
    }
}
void runloop_stop() {
    extern ThreadContext *ctx;
    // First, try to stop the runloop directly.
    debug("[JAUNCH-MACOS] Invoking CFRunLoopStop");
    CFRunLoopStop(CFRunLoopGetMain());
    debug("[JAUNCH-MACOS] CFRunLoopStop completed");

    // Note: On macOS, GUI frameworks like Java AWT/Swing fundamentally
    // alter the CoreFoundation runloop state during initialization, making
    // clean shutdown extremely difficult. When AWT initializes, it:
    //
    // 1. Adds 15+ runloop modes (vs. 1 for non-GUI apps):
    //    - AWTRunLoopMode
    //    - NSEventTrackingRunLoopMode
    //    - NSModalPanelRunLoopMode
    //    - NSGraphicsRunLoopMode
    //    - And 11+ others...
    //
    // 2. Installs event sources and timers that keep the runloop active.
    //
    // Once AWT has made these changes, the CFRunLoopStop function can no
    // longer stop the runloop. Here are some things we tried to make it work:
    //
    // 1. Custom CFRunLoopSource with callbacks:
    //    - Created custom runloop source to signal shutdown
    //    - Added to default mode and signaled via CFRunLoopSourceSignal()
    //    - Callback never gets invoked when AWT modes dominate
    //
    // 2. Short polling intervals with volatile flags:
    //    - Used CFRunLoopRunInMode() with 0.1s timeouts
    //    - Checked volatile sig_atomic_t flag between iterations
    //    - But CFRunLoopRunInMode() NEVER RETURNS after AWT init
    //    - Pre-AWT: returns normally with kCFRunLoopRunTimedOut every 0.1s
    //    - Post-AWT: never returns, not even after minutes of waiting
    //    - AWT sources/timers/observers might keep runloop perpetually busy?
    //
    // 3. CFRunLoopWakeUp + CFRunLoopStop approach:
    //    - Attempted to wake up the runloop before stopping it
    //    - Still fails because CFRunLoopRunInMode never processes the signals
    //    - Main thread polling loop remains stuck in the never-returning call
    //
    // Therefore, as a fallback, we implement a timeout mechanism to detect
    // when the runloop fails to shut down cleanly and force-exit if needed.

    // Give the runloop 2 seconds to shut down gracefully
    const double timeout_seconds = 2.0;
    const double start_time = CFAbsoluteTimeGetCurrent();

    while (ctx->state == STATE_RUNLOOP) {
        double elapsed = CFAbsoluteTimeGetCurrent() - start_time;
        if (elapsed > timeout_seconds) {
            debug("[JAUNCH-MACOS] CFRunLoop failed to terminate within %.1fs; forcing process exit", timeout_seconds);
            exit(ctx->exit_code);
        }

        // Check every 50ms
        usleep(50000);
    }

    debug("[JAUNCH-MACOS] CFRunLoop has successfully terminated! ^_^");
}

int init_threads() { return SUCCESS; }

/*
 * The macOS way of displaying a graphical error message.
 *
 * It uses Objective C calls to initialize the application,
 * then create, configure, and display the alert.
 *
 * The reason the code is ugly and hard to read is because we
 * are calling into Objective C from pure C, which goes against
 * the grain of Apple's recommended technology choices.
 * (If you are an expert macOS C developer reading this, please
 * feel warmly invited to file an issue or PR improving this!)
 */
void show_alert(const char *title, const char *message) {
    // Note: This function was generated by Claude.ai. It works, but
    // we make no guarantees about its awesomeness or lack thereof. :-)

    // Get necessary classes
    Class NSAutoreleasePool = objc_getClass("NSAutoreleasePool");
    Class NSApplication = objc_getClass("NSApplication");
    Class NSString = objc_getClass("NSString");
    Class NSAlert = objc_getClass("NSAlert");

    // Create autorelease pool
    id pool = ((id (*)(id, SEL))objc_msgSend)((id)NSAutoreleasePool, sel_registerName("alloc"));
    pool = ((id (*)(id, SEL))objc_msgSend)(pool, sel_registerName("init"));

    // Initialize application
    ((void(*)(void))NSApplicationLoad)();  // Cast the function pointer
    id app = ((id (*)(id, SEL))objc_msgSend)((id)NSApplication, sel_registerName("sharedApplication"));

    // Create strings
    id nsTitle = ((id (*)(id, SEL, const char*))objc_msgSend)((id)NSString,
        sel_registerName("stringWithUTF8String:"), title);
    id nsMessage = ((id (*)(id, SEL, const char*))objc_msgSend)((id)NSString,
        sel_registerName("stringWithUTF8String:"), message);

    // Create and configure alert
    id alert = ((id (*)(id, SEL))objc_msgSend)((id)NSAlert, sel_registerName("alloc"));
    alert = ((id (*)(id, SEL))objc_msgSend)(alert, sel_registerName("init"));
    ((void (*)(id, SEL, id))objc_msgSend)(alert, sel_registerName("setMessageText:"), nsTitle);
    ((void (*)(id, SEL, id))objc_msgSend)(alert, sel_registerName("setInformativeText:"), nsMessage);

    // Show alert
    ((void (*)(id, SEL))objc_msgSend)(alert, sel_registerName("runModal"));

    // Release pool
    ((void (*)(id, SEL))objc_msgSend)(pool, sel_registerName("drain"));
}

/*
 * The macOS way of launching a runtime.
 *
 * The behavior depends on the runloop mode:
 * - "main": Launch on main thread with event loop (like Java's -XstartOnFirstThread flag)
 * - "park": Launch on pthread, main thread runs the event loop (like OpenJDK's default behavior)
 * - "none": Launch on main thread, no event loop (e.g. Python Qt apps)
 */
int launch(const LaunchFunc launch_runtime,
    const size_t argc, const char **argv)
{
    extern ThreadContext *ctx;
    int runtime_result = SUCCESS;

    // Note: For "park" mode, this function will be invoked from the already
    // active thread, whereas for "main" and "none" modes, it will be invoked
    // from the main thread. Therefore, we only need to differentiate between
    // "main" and "none" here.

    int main_mode = ctx->runloop_mode && strcmp(ctx->runloop_mode, "main") == 0;
    if (main_mode) {
        // GUI frameworks like SWT need the runtime to run on the main thread, but
        // might expect the following setup to have been performed. Needs testing!

        // Initialize NSApplication if needed (like OpenJDK does).
        // This ensures AppKit is properly set up for GUI applications.
        // It does *not* start the event loop, though; that will be the
        // responsibility of the launched program within the runtime.
        debug("[JAUNCH-MACOS] Invoking NSApplicationLoad (-XstartOnFirstThread style)");
        NSApplicationLoad();

        // Use NSAutoreleasePool for proper Objective-C memory management.
        debug("[JAUNCH-MACOS] Configuring autorelease pool (-XstartOnFirstThread style)");
        Class NSAutoreleasePool = objc_getClass("NSAutoreleasePool");
        id pool = ((id (*)(id, SEL))objc_msgSend)((id)NSAutoreleasePool, sel_registerName("alloc"));
        pool = ((id (*)(id, SEL))objc_msgSend)(pool, sel_registerName("init"));

        debug("[JAUNCH-MACOS] Launching runtime (\"main\" mode)");
        runtime_result = launch_runtime(argc, argv);
        debug("[JAUNCH-MACOS] Runtime finished with code: %d", runtime_result);

        debug("[JAUNCH-MACOS] Cleaning up autorelease pool (-XstartOnFirstThread style)");
        ((void (*)(id, SEL))objc_msgSend)(pool, sel_registerName("drain"));
    }
    else {
        // Either "none" or "park" mode, depending on the current thread.
        debug("[JAUNCH-MACOS] Launching runtime");
        runtime_result = launch_runtime(argc, argv);
        debug("[JAUNCH-MACOS] Runtime finished with code: %d", runtime_result);
    }

    return runtime_result;
}
