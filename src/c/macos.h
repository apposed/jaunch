#include <CoreFoundation/CoreFoundation.h>
#include <objc/objc.h>
#include <objc/runtime.h>
#include <objc/message.h>
#include <pthread.h>

// Declare needed AppKit function without including AppKit,
// to avoid difficulties with Objective-C versus pure C.
extern void NSApplicationLoad(void);

#include "common.h"

#define OS_NAME "macos"

struct LaunchConfiguration {
    LaunchFunc launch_runtime;
    size_t argc;
    const char **argv;
};

static struct LaunchConfiguration config = {
    .launch_runtime = NULL,
    .argc = 0,
    .argv = NULL
};

static void dummy_call_back(void *info) { }

static void *launch_on_macos(void *dummy) {
    exit(config.launch_runtime(config.argc, config.argv));
}

// ===========================================================
//              common.h FUNCTION IMPLEMENTATIONS
// ===========================================================

void init_threads() {}

/*
 * The macOS way of displaying a graphical error message.
 *
 * It uses Objective C calls to initialize the application,
 * then create, configure, and display the alert.
 *
 * The reason the code is ugly and hard to read is because we
 * are calling into Objective C from pure C, which goes against
 * the grain of Apple's recommended technology choices.
 * (If you are an expert macOS C developer reading this, please
 * feel warmly invited to file an issue or PR improving this!)
 */
void show_alert(const char *title, const char *message) {
    // Note: This function was generated by Claude.ai. It works, but
    // we make no guarantees about its awesomeness or lack thereof. :-)

    // Get necessary classes
    Class NSAutoreleasePool = objc_getClass("NSAutoreleasePool");
    Class NSApplication = objc_getClass("NSApplication");
    Class NSString = objc_getClass("NSString");
    Class NSAlert = objc_getClass("NSAlert");

    // Create autorelease pool
    id pool = ((id (*)(id, SEL))objc_msgSend)((id)NSAutoreleasePool, sel_registerName("alloc"));
    pool = ((id (*)(id, SEL))objc_msgSend)(pool, sel_registerName("init"));

    // Initialize application
    ((void(*)(void))NSApplicationLoad)();  // Cast the function pointer
    id app = ((id (*)(id, SEL))objc_msgSend)((id)NSApplication, sel_registerName("sharedApplication"));

    // Create strings
    id nsTitle = ((id (*)(id, SEL, const char*))objc_msgSend)((id)NSString,
        sel_registerName("stringWithUTF8String:"), title);
    id nsMessage = ((id (*)(id, SEL, const char*))objc_msgSend)((id)NSString,
        sel_registerName("stringWithUTF8String:"), message);

    // Create and configure alert
    id alert = ((id (*)(id, SEL))objc_msgSend)((id)NSAlert, sel_registerName("alloc"));
    alert = ((id (*)(id, SEL))objc_msgSend)(alert, sel_registerName("init"));
    ((void (*)(id, SEL, id))objc_msgSend)(alert, sel_registerName("setMessageText:"), nsTitle);
    ((void (*)(id, SEL, id))objc_msgSend)(alert, sel_registerName("setInformativeText:"), nsMessage);

    // Show alert
    ((void (*)(id, SEL))objc_msgSend)(alert, sel_registerName("runModal"));

    // Release pool
    ((void (*)(id, SEL))objc_msgSend)(pool, sel_registerName("drain"));
}

/*
 * The macOS way of launching a runtime.
 *
 * It starts a new thread using pthread_create, which calls the launch function.
 * Meanwhile, on this thread (main), the CoreFoundation event loop is run.
 * All so that Java's AWT subsystem can work without freezing up the process.
 */
int launch(const LaunchFunc launch_runtime, const size_t argc, const char **argv) {
    // Save arguments into global struct, for later retrieval.
    config.launch_runtime = launch_runtime;
    config.argc = argc;
    config.argv = argv;

    // Call the launch function on a dedicated thread.
    pthread_t thread;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&thread, &attr, launch_on_macos, NULL);
    pthread_attr_destroy(&attr);

    // Run the AppKit event loop here on the main thread.
    CFRunLoopSourceContext context;
    memset(&context, 0, sizeof(context));
    context.perform = &dummy_call_back;

    CFRunLoopSourceRef ref = CFRunLoopSourceCreate(NULL, 0, &context);
    CFRunLoopAddSource (CFRunLoopGetCurrent(), ref, kCFRunLoopCommonModes);
    CFRunLoopRun();

    return 0;
}
