import kotlinx.cinterop.*
import kotlinx.cinterop.alloc
import jni.*
import platform.posix.*
import kotlin.experimental.ExperimentalNativeApi

@OptIn(ExperimentalForeignApi::class, ExperimentalNativeApi::class)
fun main(args: Array<String>) {
    // Load libjvm dynamically
    val jvmLibName = when (Platform.osFamily) {
        OsFamily.WINDOWS -> "jvm.dll"
        OsFamily.MACOSX -> "libjli.so"
        OsFamily.LINUX -> "libjvm.so"
        else -> error("Unsupported operating system")
    }

    val jvmLib = dlopen(jvmLibName, RTLD_LAZY or RTLD_GLOBAL)
    if (jvmLib == null) {
        println("Error loading $jvmLibName: ${dlerror()?.toKString()}")
        return
    }

    try {
        // Initialize JVM
        //val version = JNI_VERSION_1_8
        //val ignoreUnrecognized = 1
        option0.optionString = cstr("-Djava.class.path=/path/to/your/app.jar")
        val options = {option0}
        NativePtr()
        val vmArgs = JavaVMInitArgs()
        vmArgs.version = JNI_VERSION_1_8
        vmArgs.options = options
        vmArgs.nOptions = 1
        //val vmArgs = JavaVMInitArgs(version, ignoreUnrecognized, options)

        val vm: CPointerVar<JavaVMVar> = nativeHeap.alloc()
        val env: CPointerVar<JNIEnvVar> = nativeHeap.alloc()

        if (JNI_CreateJavaVM(vm.ptr.reinterpret(), env.ptr.reinterpret(), vmArgs.ptr) != JNI_OK) {
            println("Error creating Java VM")
            return
        }

        // Find main class and method
        val jniEnv = JNIEnv(env.value)
        val mainClass = jniEnv.FindClass("your/package/YourMainClass")
        val mainMethod = jniEnv.GetStaticMethodID(mainClass, "main", "([Ljava/lang/String;)V")

        // Invoke main method
        jniEnv.CallStaticVoidMethod(mainClass, mainMethod, null)

        // Detach current thread from JVM
        vm.value?.pointed?.DetachCurrentThread?.invoke(vm.value)
    } finally {
        // Close the library handle
        dlclose(jvmLib)
    }
}
