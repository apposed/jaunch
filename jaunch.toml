# ==============================================================================
# *** Welcome to the Jaunch configuration file! ***
# ==============================================================================
#
# This jaunch.toml file contains useful general-purpose, non-application-specific
# configuration that defines some sensible defaults for typical Java-based launchers.
# You can of course edit it to customize Jaunch's behavior however you like!
#
# Each application will typically have its own extensions to the general configuration
# defined in another TOML file named the same as its native launcher executable.
# For example, if you have a native executable named fizzbuzz for launching your
# FizzBuzz application, you would also write a fizzbuzz.toml companion file that
# overrides or augments this configuration with fizzbuzz-specific settings.
#
# Minimally, such application-specific configuration will include the `program-name`
# and `main-class` (or `main-class-candidates`) fields, and typically a `classpath`
# for needed JAR files. But it may also add application-specific options via the
# `supported-options` field, as well as constraints such as `version-min` and
# `version-max` to restrict which Javas are compatible with the application.
#
# Alternately, if you would like to keep all configuration together in one file
# for simplicity, you can write a single TOML file with everything, and name it
# either `jaunch.toml` or the same as your native launcher (e.g. `fizzbuzz.toml`).
#
# Without further ado, let's get started with the configuration!

# ==============================================================================
# The version of Jaunch with which this configuration file is intended to work.
# Leave this value be, unless you are upgrading from an older version of Jaunch.
jaunch-version = 1

# ==============================================================================
# The name of your program! This name will appear in the usage text.
#program-name = 'Awesome-Sauce'

# ==============================================================================
# The list of command line options supported by Jaunch out of the box.
#
# These are arguments that Jaunch will interpret, transforming them in various ways
# into arguments to the Java Virtual Machine (JVM) and/or main class that is launched.
#
# Two quick examples from the below list:
#
# 1. The --headless option configures Jaunch to pass the flag -Djava.awt.headless=true
#    to the JVM. This makes it friendlier for CLI users to launch your application in
#    headless mode, without knowing anything about the Java platform specifically.
#
# 2. Similarly, --heap=1234m (aliased also to --mem and --memory) will be transformed
#    into a -Xmx1234m argument to the JVM, so that users have an easier-to-remember
#    option for setting the max heap size, without memorizing Java's -Xmx terminology.
#
# (In both of these examples, the transformations described are defined within the
# jvm-args section toward the bottom of the file. But be patient! You'll get there.)
#
# The syntax here is hopefully self-explanatory by reading through the list.
# But here are the technical details anyway just in case:
#
# * The pipe symbol (|) divides the declaration of the option itself from its help text.
#   The help text is not required, but recommended, and will be shown when Jaunch's help
#   directive is invoked (which happens out of the box when the --help option is given).
#
# * Options may be standalone (like --headless), or may take a parameter (like --heap).
#
# * To declare an option as requiring a parameter, simply write an equals sign (=) after
#   the option flag (see e.g. the --heap option below). What you write after the equals
#   sign does not matter, except that it will be shown that way in the help text.
#
# * Jaunch parses parameters given as either a single argument --heap=789m with an
#   equals sign (=), or as two arguments (--heap 789m) separated by a space.
#
# * The parameter value given by the user will be stored into Jaunch's variables using
#   the canonical name of the option in question. So for example, --heap=789m will store
#   the value "789m" into the variable called heap. (If the user passed --mem=789m, the
#   exact same thing would happen, storing the value into the heap variable, because
#   --heap is the first and therefore canonical name of that option.) We will see later
#   in the configuration file how to use these captured parameter values.
#
# * Options may have any number of aliases, separated by commas. See e.g. --heap below.
#
# * If you need to use an actual pipe symbol (|) as part of your option or help text, you
#   can't, sorry! It's not a good idea anyway, because that symbol is used by shells to
#   indicate I/O piping between processes. So making it part of an option would be super
#   tricky and confusing. That's why Jaunch uses the pipe symbol as its separator:
#   because it is very unlikely to be needed as an actual character anywhere.
supported-options = [
    '--help,-h|show this help',
    '--dry-run|show the command line, but do not run anything',
    '--info|informational output',
    '--debug|verbose output',
    '--system|do not try to run bundled Java',
    '--java-home=<path>|specify JAVA_HOME explicitly',
    '--print-java-home|print path to the selected Java',
    '--print-java-info|print information about the selected Java',
    '--print-app-dir|print directory where the application is located',
    '--headless|run in text mode',
    "--heap,--mem,--memory=<amount>|set Java's heap size to <amount> (e.g. 512M)",
    '--class-path,--classpath,-classpath,--cp,-cp=<path>|append <path> to the class path',
    '--jar-path,--jarpath,-jarpath=<path>|append .jar files in <path> to the class path',
    "--ext=<path>|set Java's extension directory to <path>",
    '--debugger=<port>[,suspend]|start Java in a mode so an IDE/debugger can attach to it',
]

# ==============================================================================
# The list of arguments that Jaunch will recognize as belonging to the JVM,
# rather than your application's main method.
#
# These are used to guess, when the minus-minus divider (--) is absent, whether each arg
# is a JVM one or a main one. Note that as with the classpath field, the asterisk symbol
# (*) is a wildcard. All values on this list are assumed to be given with at least one
# dash symbol prepended, maybe two. (Heck, go nuts and put three or four if you want!
# Java won't like it, though.)
#
# About main method arguments: Jaunch's philosophy is to remain agnostic of the options
# your application supports, rather than trying to constrain them in its configuration
# and checking them itself. As such, it is your application's responsibility to emit
# error messages as appropriate if it encounters displeasing arguments.
#
# For example, suppose the user invokes:
#
#     ./fizzbuzz 1 2 3 4 5 -Xms1g 
#
# Because 'X' is on the recognized-jvm-args list out of the box, Jaunch will translate
# this invocation to:
#
#     java -Xms1g org.fizzbuzz.FizzBuzz 1 2 3 4 5
#
# Even though the Java argument appears after the main class arguments. Your users can
# mix and match to their hearts' content, being as sloppy as they want, and Jaunch will
# sort out the mess! As long as the JVM args are on the list here, of course.
recognized-jvm-args = [
    '?',
    'D*',
    'X*',
    'agentlib',
    'agentpath',
    'client',
    'd32',
    'd64',
    'da',
    'disableassertions',
    'disablesystemassertions',
    'dsa',
    'ea',
    'enableassertions',
    'enablesystemassertions',
    'esa',
    'help',
    'jar',
    'javaagent',
    'jre-restrict-search',
    'no-jre-restrict-search',
    'server',
    'showversion',
    'splash',
    'verbose',
    'version',
]

# ==============================================================================
# Whether to allow unrecognized arguments to be passed to the JVM.
#
# When the minus-minus divider is absent, the only args that end up as JVM args will be
# ones from the list above. But if the minus-minus divider *is* given, it becomes
# possible to force a particular argument to be construed as a JVM argument, even when
# it does not appear on the list. Depending on your application, it might not be
# desirable for such unrecognized JVM args to be allowed through to the Java launch.
#
# If you want to allow all user-specified JVM args through to the Java launch, set this
# value to true.
#
# If you want full control over what arguments the user can pass to the JVM, set this
# value to false, and edit the recognized-jvm-args list above according to your needs.
# Then Jaunch will fail fast when told to pass an unrecognized option to Java.
#
# For example, suppose the user invokes:
#
#     ./fizzbuzz -ZZ:SuperSecretOption -- 1 2 3 4 5
#
# Jaunch would translate this into something like:
#
#     java -ZZ:SuperSecretOption org.fizzbuzz.FizzBuzz 1 2 3 4 5
#
# You and I both know that Java will barf when confronted with an argument like
# -ZZ:SuperSecretOption! But maybe you are using a custom build of OpenJDK produced by
# your organization's new superintelligent AI, which actually *does* have this option!
# Who is Jaunch to judge? (In that case, I would argue you should really just add
# '-ZZ:*' to your list of recognized JVM args above, but then I would be judging!)
# Or maybe you just want to trust your users as OpenJDK evolves, rather than dealing
# with the bureaucracy of updating the TOML file every time OpenJDK changes its
# supported options. In such cases, this option is here for you!
allow-unrecognized-jvm-args = false

# ==============================================================================
# Acceptable range of Java versions to match.
#
# These two options let you constrain the minimum and maximum Java versions respectively
# that your application supports. This information will be used when searching the
# system for appropriate JVM installations. If a JVM is successfully discovered, but
# then found to be outside these constraints, it is discarded and the search continues.
#
# The most common use of these fields is to specify major versions alone (e.g.
# "java-version-min = 11"), but Jaunch does make a best effort to compare version
# strings digit by digit in a Semantic-Versioning-like way. YMMV, though.
#java-version-min = 8
#java-version-max = 21

# ==============================================================================
# Whether to attempt to launch with mysterious flavors of the JVM.
#
# When Jaunch discovers a Java installation on the user's system, it tries very hard
# to understand the details of that installation, including Java version, distribution
# (see below), operating system, and CPU architecture, so that it can respect the
# constraints defined in this config file.
#
# However, the variability across JVM distributions is actually quite a lot:
#
# * The vast majority of distros include a file named 'release' with important metadata
#   fields inside. But a few distros are missing that file (e.g. Corretto 1.8.0_265-b01
#   for x64 Linux), and a few others are missing needed metadata fields (e.g. Liberica
#   1.8.0_392 for x64 Linux, which is missing IMPLEMENTOR), or they might put something
#   stupid as a value (e.g. JBRSDK 11.0.6 for x64 Linux, which has IMPLEMENTOR="N/A").
#
# * For that reason, Jaunch also parses the directory name of the installation, trying
#   to extract this information. But the naming schemes across distro are also very
#   diverse and sometimes uninformative (e.g. JBRSDK 11 for x64 Linux, which has the
#   vague folder name of "jbrsdk" with no version, or JBRSDK 8 for Linux, which has no
#   directory prefix at all), and of course users and packaging scripts can rename the
#   distro root directory to anything, corrupting this information in the process.
#
# * As of this writing, Jaunch does not actually go so far as to scan Java binaries for
#   human-readable strings (a la the strings *nix utility), nor does it actually invoke
#   bin/java on a Java program that prints System.getProperty("java.version") and
#   related fields. It could! But doing that would slow down launch, and it starts to
#   get ridiculous because such weird distros are in the small minority.
#
# Therefore, it is possible for all of Jaunch's efforts to be in vain, and to end up
# trying to decide whether to launch with some mystery-flavored JVM. In such scenarios,
# the allow-weird-jvms flag comes to the rescue, telling Jaunch whether to allow it
# (true), or give up and complain (false). Hopefully, your users will never know the
# difference, as long as they have well-behaved distros, and/or you ship a good distro
# with your application. But just in case, give a think to how you want this to behave.
allow-weird-jvms = true

# ==============================================================================
# Acceptable and unacceptable distributions/vendors/flavors of Java to match.
#
# These two options let you constrain which Java distributions are OK to use and which
# are not, respectively. For distros matching neither the allowlist nor blocklist, what
# Jaunch does will depend on the allow-weird-jvms boolean setting above.
#
# As of this writing, the following Java distributions have been tested:
#
# Distribution       | IMPLEMENTOR              | IMPLEMENTOR_VERSION prefix             | root folder slug
# -------------------| -------------------------|----------------------------------------|-----------------
# AdoptOpenJDK       | AdoptOpenJDK             | AdoptOpenJDK                           | adopt
# Alibaba Dragonwell | Alibaba                  | (Alibaba Dragonwell Extended Edition)* | dragonwell
# Amazon Corretto    | Amazon.com Inc.*         | Corretto*                              | corretto or amazon-corretto
# Azul Zulu          | Azul Systems, Inc.*      | Zulu*                                  | zulu
# BellSoft Liberica  | BellSoft                 | <none>                                 | <none>
# Eclipse Temurin    | Eclipse Adoptium         | Temurin                                | <none>
# IBM Semuru         | IBM Corporation          | <none>                                 | <none>
# JetBrains JBRSDK   | N/A or JetBrains s.r.o.* | JBRSDK*                                | jbrsdk*
# Microsoft OpenJDK  | Microsoft                | Microsoft                              | <none>
# OpenLogic OpenJDK  | OpenLogic                | OpenLogic-OpenJDK                      | openlogic-openjdk
# GraalVM Community  | GraalVM Community        | <none>                                 | graalvm-ce or graalvm-community-openjdk
# GraalVM Enterprise | Oracle Corporation       | <none>                                 | graalvm-jdk
# Oracle Java SE     | Oracle Corporation       | <none>                                 | oracle*
# Oracle OpenJDK     | Oracle Corporation       | <none>                                 | oracle*
# SAP SapMachine     | SAP SE                   | SapMachine                             | sapmachine-jdk
# Tencent KonaJDK    | Tencent*                 | TencentKonaJDK*                        | TencentKona
# Ubuntu OpenJDK     | Ubuntu or Private Build  | <none>                                 | <none>
#
# An asterisk (*) means that that metadata field, and/or the entire release file, is
# missing -- or for slugs, that there is no slug -- for some versions of that distro.
# Generally speaking, metadata and naming have improved as Java has evolved; often it
# is Java 8 versions of these distributions that have the most metadata/naming issues.
#
# It is quite often (but far from always) the case that root folders begin with the
# prefix 'jdk_', so Jaunch strips any such prefix before inferring root folder slugs.
#
# As the table above shows, every observed distro has some telltale signs, with the
# release file being more likely to provide useful information, but there are many
# exceptions, so Jaunch uses all available sources when scrutinizing installations. 
# Fields are downcased, then checked for substrings matching any of the tokens below.
java-distros-allowed = [
    'adoptopenjdk',                   # AdoptOpenJDK
    'alibaba', 'dragonwell',          # Alibaba Dragonwell
    'amazon', 'corretto',             # Amazon Corretto
    'azul', 'zulu',                   # Azul Zulu
    'bellsoft', 'liberica',           # Bellsoft Liberica
    'eclipse', 'adoptium', 'temurin', # Eclipse Temurin
    'ibm', 'semuru',                  # IBM Semuru
    'jetbrains', 'jbrsdk',            # JetBrains JBRSDK
    'microsoft',                      # Microsoft OpenJDK
    'openlogic',                      # OpenLogic OpenJDK
    'graalvm-c',                      # GraalVM Community
    'graalvm-jdk',                    # GraalVM Enterprise
    'oracle',                         # Oracle Java SE, Oracle OpenJDK
    'sapmachine',                     # SAP SapMachine
    'tencent', 'kona',                # TencentKona
    'ubuntu',                         # Ubuntu OpenJDK
]
java-distros-blocked = []

# ==============================================================================
# Developer aside: Right now, Jaunch only filters Java installations by distro,
# version, OS, and CPU arch. But there are further criteria it could support:
#
# * Java Development Kit (JDK) vs. Java Runtime Environment (JRE).
# * Availability of optional features such as CRaC or JavaFX/OpenJFX.
# * Minimum and/or maximum versions of operating systems (Windows 11+).
# * More complex version filtering rules, e.g. multiple version exclusion ranges.
#
# Implementing such additional criteria will be done according to user demand.
# If you need these, pull requests are welcome: https://github.com/scijava/jaunch

# ==============================================================================
# Paths to check for Java installations.
#
# This is a list of directories where Jaunch might hope to find a Java installation.
# Directories are checked sequentially until one is found that matches all criteria.
#
# This is also the first field where we see Jaunch's hints/rules system in action.
# Each entry on the root-dirs list may be prefixed with string separated by pipes.
# Each segment is a *hint* for Jaunch regarding a flag that must be set for that
# particular line to be considered. Jaunch sets hint flags based on a few sources:
#
# * Active operating system: OS:MACOSX, OS:LINUX, OS:WINDOWS,
#   OS:IOS, OS:ANDROID, OS:WASM, OS:TVOS, OS:WATCHOS, or OS:UNKNOWN.
#
# * Active CPU architecture: ARCH:ARM32, ARCH:ARM64, ARCH:X86, ARCH:X64,
#   ARCH:MIPS32, ARCH:MIPSEL32, ARCH:WASM32, or ARCH:UNKNOWN.

# * Option hints, set from arguments passed to Jaunch, each of which sets a matching
#   hint. For example, passing the --headless option will set a hint '--headless'.
#
# * Mode hints, set from evaluation of the modes field (see below).
#
# * Java hints, based on the Java installation selected:
#   - JAVA:8 if the selected Java installation is version 8.
#   - JAVA:8+ if the selected Java installation is version 8 or later.
#   - JAVA:9 if the selected Java installation is version 9.
#   - JAVA:9+ if the selected Java installation is version 9 or later.
#   - and so on.
#   Of course, Java hints will only be set after a Java installation matches,
#   so they won't work here in root-paths, nor in libjvm-suffixes.
#   But they can be useful in the jvm-args section to ensure Jaunch passes
#   JVM args only to those versions of the JVM that support them, such as the
#   JPMS-related flags like --add-opens which were introduced in Java 9.
#
# Finally, a segment prefixed by a bang symbol (!) negates the hint,
# making that line match only when that particular hint is *not* set.
#
# For example, consider the following root-paths line:
#
#     '!--system|OS:WINDOWS|ARCH:X64|java/win64',
#
# The applicable hints are !--system, OS:WINDOWS, and ARCH:X64, so the root path
# of java/win64 will only be considered on 64-bit Windows systems, and only when
# the --system option was *not* given as part of the launcher invocation.
#
# This is also the first field where we see Jaunch's variables in use:
#
#     '--java-home|${java-home}'
#
# Thanks to the above line, when the user passes '--java-home=/the-best-jdk', the
# --java-home hint will be set, and the java-home variable will be set to /the-best-jdk.
# So not only will the line match, but the root path to check will become /the-best-jdk.
# 
# Similarly, variable expressions are also sourced from environment variables, so
# the '${JAVA_HOME}' line will be populated with the JAVA_HOME environment variable.
root-paths = [
    '--java-home|${java-home}',
    '${JAVA_HOME}',
    '!--system|OS:LINUX|ARCH:X64|java/linux64',            # TODO: Fiji-specific?
    '!--system|OS:LINUX|ARCH:X86|java/linux',              # TODO: Fiji-specific?
    '!--system|OS:LINUX|ARCH:X86|java/linux32',            # TODO: Fiji-specific?
    '!--system|OS:MACOSX|ARCH:ARM64|java/macosx-arm64',    # TODO: Fiji-specific?
    '!--system|OS:MACOSX|ARCH:X64|java/macosx',            # TODO: Fiji-specific?
    '!--system|OS:WINDOWS|ARCH:X64|java/win64',            # TODO: Fiji-specific?
    '!--system|OS:WINDOWS|ARCH:X86|java/win32',            # TODO: Fiji-specific?
    '${CONDA_PREFIX}/pkgs/openjdk*/lib/jvm',               # Conda (openjdk 9+)
    '${CONDA_PREFIX}/pkgs/openjdk*',                       # Conda (openjdk 8)
    'OS:LINUX|/usr/lib/jvm',                               # Linux distro package manager (e.g. apt)
    'OS:LINUX|/var/lib/flatpak/...',                       # TODO: Flatpak
    'OS:LINUX|~/.sdkman/candidates/java',                  # sdkman.io
    'OS:LINUX|~/.cache/cjdk/v*/jdks/*',                    # github.com/cachedjdk/cjdk
    'OS:LINUX|~/.jdk',                                     # github.com/jyksnw/install-jdk
    'OS:LINUX|~/.jre',                                     # github.com/jyksnw/install-jdk
    'OS:MACOSX|/Library/Java/JavaVirtualMachines',         # Java 8+
    'OS:MACOSX|/usr/local/...',                            # TODO: Homebrew
    'OS:WINDOWS|C:/Program Files/Java',
    'OS:WINDOWS|C:/Program Files (x86)/Java',
    'OS:WINDOWS|~/scoop/Apps/...',                         # TODO: Scoop
]

# ==============================================================================
# Developer aside: Right now, Jaunch does not utilize any programmatic ways
# to discover Java root directories. But it could! In particular:
#
# - Windows: look for registry keys
# - macOS: /usr/libexec/java_home -V
# - Linux: /usr/sbin/update-java-alternatives -l
#
# We could invent schema elements for toggling use of these detection approaches.
# For but for now: YAGNI! File an issue or a pull request if you do need it.

# ==============================================================================
# List of places within a Java installation to look for the JVM library.
#
# For example, if the root directory currently being considered is
# /the-best-jvm, and the current libjvm suffix line is lib/server/libjvm.so,
# then Jaunch will check the path /the-best-jvm/lib/server/libjvm.so for the
# library. If found, we have a winning Java installation!
#
# Perusing the list below, you may notice several entries beginning with jre/.
# This nested jre/ folder is only present for OpenJDK 8, nothing after.
#
# One other point of note: on macOS, some distros have *two* libjli.dylib files:
# the first in one of the usual spots under Contents/Home, and the second oddly
# in Contents/MacOS. Perhaps surprisingly: the two files are not binary identical.
# Testing is needed to determine if there's any difference in behavior based on which
# one gets linked. For now, Jaunch opts to ignore the one in Contents/MacOS, since
# no known version of any distribution has solely the Contents/MacOS/libjli.dylib.
libjvm-suffixes = [
    'OS:LINUX|lib/server/libjvm.so',                     # Java 9+
    'OS:LINUX|jre/lib/amd64/server/libjvm.so',           # Java 8 (64-bit)
    'OS:LINUX|jre/lib/i386/server/libjvm.so',            # Java 8 (32-bit)
    'OS:LINUX|jbr/lib/server/libjvm.so',                 # jbrsdk_11.0.8_x64
    'OS:MACOSX|Contents/Home/jre/lib/jli/libjli.dylib',  # Java 8
    'OS:MACOSX|Contents/Home/lib/jli/libjli.dylib',      # Java 9-11
    'OS:MACOSX|Contents/Home/lib/libjli.dylib',          # Java 12+
    #'OS:MACOSX|Contents/MacOS/libjli.dylib',             # some distros Java 8+
    'OS:MACOSX|Contents/Libraries/libjli.jnilib',        # Apple Java 6
    'OS:WINDOWS|bin/server/jvm.dll',                     # Java 9+
    'OS:WINDOWS|bin/client/jvm.dll',                     # Java 9+
    'OS:WINDOWS|jre/bin/server/jvm.dll',                 # Java 8
    'OS:WINDOWS|jre/bin/client/jvm.dll',                 # Java 8
]

# ==============================================================================
# List of additional hints to enable or disable based on other hints.
#
# See "root-paths" above for an overview of hints.
#
# With modes, you can set a single hint in response to several different other hints,
# which can help to consolidate rules in other sections of the configuration.
# Modes can also be used to negate hints. It's easiest to explain via an example.
# Suppose your program wants to support the following three options:
#
# * --headless, which enables headless mode, disabling the GUI.
# * --batch, which enables a mode to run sequential computations.
# * --big-gui, to use the *BIG* GUI, when you like it large!
#
# Let's say that use of the batch mode implies headless operation,
# while use of the big GUI is incompatible with headless.
#
# You might define the following modes here:
#
#     '--headless|headless',
#     '--batch|headless',
#     '--big-gui|!headless',
#
# In this way, whenever either --headless or --batch is passed, the headless mode hint
# will be enabled, and whenever --big-gui is passed, the headless mode is disabled.
# If multiple conflicting arguments are passed, the ultimate state of headless mode will
# depend on the order of such arguments, since mode lines are evaluated sequentially.
modes = []

# ==============================================================================
# Commands that override Jaunch's usual behavior of launching Java.
#
# Each one runs at a particular (hardcoded) time during configuration.
# Directives unsupported by the configurator program are ignored.
#
# TODO: write directives documentation here.
directives = [
  '--help|help',
  '-h|help',
  '--dry-run|dry-run',
  '--print-java-home|print-java-home',
  '--print-java-info|print-java-info',
  '--print-app-dir|print-app-dir',
]

# ==============================================================================
# Runtime classpath elements (e.g. JAR files) to pass to Java.
#
# These are typically relative paths beneath the application root directory,
# which is the same directory where the Jaunch launchers and config files reside.
#
# The asterisk wildcard symbol (*) is allowed, if you want to match all JAR files,
# or even all JARs and directories, within a particular directory.
#
# The double-asterisk (**) for recursive matching is not yet implemented,
# but could be done if there is user demand (PRs welcome ;-).
classpath = [
    '--class-path|${class-path}',
    '--jar-path|${jar-path}/*',
]

# ==============================================================================
# Maximum amount of memory for the Java heap to consume.
#
# In addition to the usual k, m, and g suffixes supported by Java itself for KB,
# MB, and GB respectively, Jaunch also supports a % suffix.
#
# Examples:
# - For 1567 MB: '1567m'
# - For 48 GB: '48g'
# - For 75% of available RAM: '75%'
# - For 3 GB less than available RAM: '-3g'
#
# These will be translated into an appropriate '-Xmx...' argument under the hood.
#
# If unset, Java's default will be used (i.e. no -Xmx argument will be injected).
#max-heap = '50%'

# ==============================================================================
# Arguments to pass to the JVM.
#
# TODO: write jvm-args documentation here.
jvm-args = [
    '--headless|-Djava.awt.headless=true',
    '--heap|-Xmx${heap}',
    '--ext|-Djava.ext.dirs=${ext}',
]

# ==============================================================================
# TODO: main-class
#
#main-class = org.fizzbuzz.FizzBuzz

# ==============================================================================
# TODO: main-class-candidates
#
#main-class-candidates = [
#    '--fizzbuzz|org.fizzbuzz.FizzBuzz'
#    '--main-class|${main-class}',
#    'org.fizzbuzz.Main', # default behavior
#]

# ==============================================================================
# TODO: main-args
#
#main-args = [
#    '--fizz|-Dfizzbuzz.mode=fizz',
#    '--buzz|-Dfizzbuzz.mode=buzz',
#]
