# *** Welcome to the Jaunch configuration file! ***
#
# This jaunch.toml file contains useful general-purpose, non-application-specific
# configuration that defines some sensible defaults for typical Java-based launchers.
# You can of course edit it to customize Jaunch's behavior however you like!
#
# Each application will typically have its own extensions to the general configuration
# defined in another TOML file named the same as its native launcher executable.
# For example, if you have a native executable named fizzbuzz for launching your
# FizzBuzz application, you would also write a fizzbuzz.toml companion file that
# overrides or augments this configuration with fizzbuzz-specific settings.
#
# Minimally, such application-specific configuration will include the `program-name`
# and `main-class` (or `main-class-candidates`) fields. But it may add application-
# specific options as well via the `supported-options` field, as well as constraints
# such as `version-min`/`version-max` to restrict which Javas to use with the app.
#
# Alternately, if you would like to keep all configuration together in one file
# for simplicity, you can write a single TOML file with everything, and name it
# either `jaunch.toml` or the same as your native launcher (e.g. `fizzbuzz.toml`).

# The version of Jaunch with which this configuration file is intended to work.
# Leave this value be, unless you are upgrading from an older version of Jaunch.
jaunch-version = 1

# Name your program here! This name will appear in the usage text.
#program-name = 'Awesome-Sauce'

# Runtime classpath elements (e.g. JAR files) to pass to Java.
classpath = []

# Maximum amount of memory for the Java heap to consume. Examples:
# - For 1567 MB: '1567m'
# - For 48 GB: '48g'
# - For 75% of available RAM: '75%'
# - For 3 GB less than available RAM: '-3g'
# These will be translated into an appropriate '-Xmx...' argument.
#max-heap = '50%'

# Order matters. So we cannot use separate sections unless we use arrays of tables,
# which gets pretty complicated. Let's use a simpler syntax instead: hints before a bar (|) symbol.
# So, for every string in the file, we split on bar and then filter by matching environments.
# Let's hope Jaunch never needs to support literal bar symbols!
#
# We can also allow the negation of any criterion by prepending with ! symbol.
# - !JAVA:8 = Every Java version except 8
# - !DISTRO:Zulu = Every Java distribution flavor except Zulu
#
# We can also support conditional flags.
# Typically, each flag on the CLI takes some number of additional parameters after it, maybe 0.
# - If it takes zero parameters, its value becomes a boolean.
# - We can say `--foo bar` and we'll get `foo=bar` in the table.
# - We can say `--foo=bar` and same.
# - We can say `--foo fizz buzz` and we'll get `foo=[fizz, buzz]` in the table.
# - We can say `--foo` and we'll get `foo=true`.
# - We can say *nothing*, and when checking for the value 'foo' in the table, we'll be told `false`.
# With this scheme, we have additive options, and can limitedly fake subtractive behavior based on falsy parameters.

supported-options = [
    '--help,-h|show this help',
    '--dry-run|show the command line, but do not run anything',
    '--info|informational output',
    '--debug|verbose output',
    '--system|do not try to run bundled Java',
    '--java-home=<path>|specify JAVA_HOME explicitly',
    '--print-java-home|print path to the selected Java',
    '--print-app-dir|print directory where the application is located',
    '--headless|run in text mode',
    "--heap,--mem,--memory=<amount>|set Java's heap size to <amount> (e.g. 512M)",
    '--class-path,--classpath,-classpath,--cp,-cp=<path>|append <path> to the class path',
    '--jar-path,--jarpath,-jarpath=<path>|append .jar files in <path> to the class path',
    "--ext=<path>|set Java's extension directory to <path>",
    '--debugger=<port>[,suspend]|start the JVM in a mode so an IDE/debugger can attach to it',
]

# These are used to guess, when the minus-minus divider is absent, whether each arg is a JVM one or a main one.
recognized-jvm-args = [
    '?',
    'D*',
    'X*',
    'agentlib',
    'agentpath',
    'client',
    'd32',
    'd64',
    'da',
    'disableassertions',
    'disablesystemassertions',
    'dsa',
    'ea',
    'enableassertions',
    'enablesystemassertions',
    'esa',
    'help',
    'jar',
    'javaagent',
    'jre-restrict-search',
    'no-jre-restrict-search',
    'server',
    'showversion',
    'splash',
    'verbose',
    'version',
]

# When the minus-minus divider is absent, the only args that end up as JVM args will be ones from the list above.
# But if the minus-minus divider *is* given, it becomes possible to force a particular argument to be construed
# as a JVM argument, even when it does not appear on the list. Depending on your application, it might not be
# desirable for such unrecognized JVM args to be allowed through to the Java launch.
#
# If you want to allow all user-specified JVM args through to the Java launch, set this value to true.
#
# If you want full control over what arguments the user can pass to the JVM, set this value to false,
# and edit the recognized-jvm-args list above according to your needs.
allow-unrecognized-jvm-args = true

# Acceptable range of Java versions to match.
#version-min = 8
#version-max = 21

# Paths to check for Java installations.
root-paths = [
    '--java-home|${java-home}',
    '${JAVA_HOME}',
    '!--system|OS:LINUX|ARCH:X64|java/linux64',            # TODO: Fiji-specific?
    '!--system|OS:LINUX|ARCH:X86|java/linux',              # TODO: Fiji-specific?
    '!--system|OS:LINUX|ARCH:X86|java/linux32',            # TODO: Fiji-specific?
    '!--system|OS:MACOSX|ARCH:ARM64|java/macosx-arm64',    # TODO: Fiji-specific?
    '!--system|OS:MACOSX|ARCH:X64|java/macosx',            # TODO: Fiji-specific?
    '!--system|OS:WINDOWS|ARCH:X64|java/win64',            # TODO: Fiji-specific?
    '!--system|OS:WINDOWS|ARCH:X86|java/win32',            # TODO: Fiji-specific?
    '${CONDA_PREFIX}/pkgs/openjdk*/lib/jvm',               # Conda (openjdk 9+)
    '${CONDA_PREFIX}/pkgs/openjdk*',                       # Conda (openjdk 8)
    'OS:LINUX|/usr/lib/jvm',                               # Linux distro package manager (e.g. apt)
    'OS:LINUX|/var/lib/flatpak/...',                       # TODO: Flatpak
    'OS:LINUX|~/.sdkman/candidates/java',                  # sdkman.io
    'OS:LINUX|~/.cache/cjdk/v*/jdks/*',                    # github.com/cachedjdk/cjdk
    'OS:LINUX|~/.jdk',                                     # github.com/jyksnw/install-jdk
    'OS:LINUX|~/.jre',                                     # github.com/jyksnw/install-jdk
    'OS:MACOSX|/Library/Java/JavaVirtualMachines',         # Java 8+
    'OS:MACOSX|/usr/local/...',                            # TODO: Homebrew
    'OS:WINDOWS|ARCH:X64|C:/Program Files/Java',
    'OS:WINDOWS|ARCH:X86|C:/Program Files (x86)/Java',
    'OS:WINDOWS|~/scoop/Apps/...',                         # TODO: Scoop
]

# And then there are programmatic ways to glean the Java installations,
# depending on operating system:
#
# - Windows: look for registry keys
# - macOS: /usr/libexec/java_home -V
# - Linux: /usr/sbin/update-java-alternatives -l
#
# TODO: Invent schema elements to toggle use of programmatic detection approaches.

# Any of the following can be bare, or nested in another JDK root folder.
# No assumption is made about the naming scheme of such a JDK root folder,
# because not all distros are predictably named. Examples:
#
# macosx  JBRSDK 8u252          : jdk/Contents/Home/jre/lib/jli/libjli.dylib
# linux64 JBRSDK 11.0.6-b520.66 : jbrsdk/lib/server/libjvm.so
# linux64 JBRSDK 11.0.8         : jbrsdk_11.0.8_x64/jbr/lib/server/libjvm.so

# The nested jre/ is only present for OpenJDK 8, nothing after.
# But one wrinkle: on macOS, some distros *also* have a libjli.dylib
# in Contents/MacOS in addition to its other location. And the two
# are *not* binary identical. Testing is needed to determine if
# there's any difference in behavior based on which one gets linked.

libjvm-suffixes = [
    'OS:LINUX|lib/server/libjvm.so',                     # Java 9+
    'OS:LINUX|jre/lib/amd64/server/libjvm.so',           # Java 8 (64-bit)
    'OS:LINUX|jre/lib/i386/server/libjvm.so',            # Java 8 (32-bit)
    'OS:LINUX|jbr/lib/server/libjvm.so',                 # jbrsdk_11.0.8_x64
    'OS:MACOSX|Contents/Home/jre/lib/jli/libjli.dylib',  # Java 8
    'OS:MACOSX|Contents/Home/lib/jli/libjli.dylib',      # Java 9-11
    'OS:MACOSX|Contents/Home/lib/libjli.dylib',          # Java 12+
    #'OS:MACOSX|Contents/MacOS/libjli.dylib',             # some distros Java 8+
    'OS:MACOSX|Contents/Libraries/libjli.jnilib',        # Apple Java 6
    'OS:WINDOWS|bin/server/jvm.dll',                     # Java 9+
    'OS:WINDOWS|bin/client/jvm.dll',                     # Java 9+
    'OS:WINDOWS|jre/bin/server/jvm.dll',                 # Java 8
    'OS:WINDOWS|jre/bin/client/jvm.dll',                 # Java 8
]

# TODO: Should we just call them "hints" rather than "modes" here?
# A mode is an activation criterion that gets manually enabled
# by the presence of options. Most modes are false by default,
# but there are some special ones that get enabled based on environment:
# - Java:
#   - `JAVA:8` - If Java 8 is selected.
#   - `JAVA:8` - If Java 9 is selected.
#   - etc.
# - Operating systems:
#   - OS:UNKNOWN, OS:MACOSX, OS:IOS, OS:LINUX, OS:WINDOWS, OS:ANDROID, OS:WASM, OS:TVOS, OS:WATCHOS
# - CPU architectures:
#   - ARCH:UNKNOWN, ARCH:ARM32, ARCH:ARM64, ARCH:X86, ARCH:X64, ARCH:MIPS32, ARCH:MIPSEL32, ARCH:WASM32
#
# Options of the form `--foo` set a corresponding mode `--foo`.
#
# Options of the form `--foo=bar` set a corresponding mode `--foo`
# and a variable `${foo}` with the value `bar` (see "Variables" below).
# (Such options may alternately be written `--foo bar` as two arguments.)
#
# Modes are used as hints for activating arguments to the JVM and main class.
modes = []

# Commands that override Jaunch's usual behavior of launching Java.
# Each one runs at a particular (hardcoded) time during configuration.
# Directives unsupported by the configurator program are ignored.
directives = [
  '--help|help',
  '-h|help',
  '--dry-run|dry-run',
  '--print-java-home|print-java-home',
  '--print-app-dir|print-app-dir',
]

# Arguments to pass to the JVM.
jvm-args = [
    '--headless|-Djava.awt.headless=true',
    '--heap|-Xmx${heap}',
    '--ext|-Djava.ext.dirs=${ext}',
]

# Runtime classpath elements to pass to the JVM.
classpath = [
    '--class-path|${class-path}',
    '--jar-path|${jar-path}/*',
]
